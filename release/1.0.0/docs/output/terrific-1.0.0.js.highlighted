<div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * Terrific JavaScript Framework v1.0.0</span>
<span class="cm"> * http://terrificjs.org</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2011, Remo Brunschwiler</span>
<span class="cm"> * Dual licensed under the MIT or GPL Version 2 licenses.</span>
<span class="cm"> * http://terrificjs.org/license</span>
<span class="cm"> *</span>
<span class="cm"> * Date: Sun, 01 May 2011 05:56:34 GMT</span>
<span class="cm"> *</span>
<span class="cm"> * @module Tc</span>
<span class="cm"> * </span>
<span class="cm"> */</span>

<span class="kd">var</span> <span class="nx">Tc</span> <span class="o">=</span> <span class="nx">Tc</span> <span class="o">||</span> <span class="p">{};</span>

<span class="cm">/*</span>
<span class="cm"> * The jQuery object.</span>
<span class="cm"> */</span>
<span class="nx">Tc</span><span class="p">.</span><span class="nx">$</span> <span class="o">=</span> <span class="nx">jQuery</span><span class="p">.</span><span class="nx">noConflict</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Contains the application base config.</span>
<span class="cm"> * The base config can be extended or overwritten either via new Application ($ctx, config)</span>
<span class="cm"> * during bootstrapping the application or via /public/js/Tc.Config.js in the project folder.</span>
<span class="cm"> *</span>
<span class="cm"> * @author Remo Brunschwiler</span>
<span class="cm"> * @namespace Tc</span>
<span class="cm"> * @class Config</span>
<span class="cm"> * @static</span>
<span class="cm"> */</span>
<span class="nx">Tc</span><span class="p">.</span><span class="nx">Config</span> <span class="o">=</span> <span class="p">{</span>
    <span class="cm">/** </span>
<span class="cm">     * The paths for the different dependency types.</span>
<span class="cm">     *</span>
<span class="cm">     * @property dependencyPath</span>
<span class="cm">     * @type Object</span>
<span class="cm">     */</span>
    <span class="nx">dependencyPath</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">library</span><span class="o">:</span> <span class="s1">&#39;/js/libraries/dynamic/&#39;</span><span class="p">,</span>
        <span class="nx">plugin</span><span class="o">:</span> <span class="s1">&#39;/js/plugins/dynamic/&#39;</span><span class="p">,</span>
        <span class="nx">util</span><span class="o">:</span> <span class="s1">&#39;/js/utils/dynamic/&#39;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">$</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/**</span>
<span class="cm">     * Responsible for application wide issues (ie. the creation of modules).</span>
<span class="cm">     *</span>
<span class="cm">     * @author Remo Brunschwiler</span>
<span class="cm">     * @namespace Tc</span>
<span class="cm">     * @class Application</span>
<span class="cm">     */</span>
    <span class="nx">Tc</span><span class="p">.</span><span class="nx">Application</span> <span class="o">=</span> <span class="nx">Class</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>

        <span class="cm">/**</span>
<span class="cm">         * Initializes the Application.</span>
<span class="cm">         *</span>
<span class="cm">         * @method init</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         * @constructor</span>
<span class="cm">         * @param {jQuery} $ctx the jquery context</span>
<span class="cm">         * @param {Object} config the configuration</span>
<span class="cm">         */</span>
        <span class="nx">init</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$ctx</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/**</span>
<span class="cm">             * The configuration.</span>
<span class="cm">             *</span>
<span class="cm">             * @property config</span>
<span class="cm">             * @type Object</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">config</span> <span class="o">=</span> <span class="nx">$</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span><span class="nx">Tc</span><span class="p">.</span><span class="nx">Config</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>

            <span class="cm">/**</span>
<span class="cm">             * The jquery context.</span>
<span class="cm">             *</span>
<span class="cm">             * @property $ctx</span>
<span class="cm">             * @type jQuery</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">$ctx</span> <span class="o">=</span> <span class="nx">$ctx</span> <span class="o">||</span> <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;body&#39;</span><span class="p">);</span>

            <span class="cm">/**</span>
<span class="cm">             * Contains references to all modules on the page.</span>
<span class="cm">             * -&gt; could be useful ie. when there are interactions between flash &lt;-&gt; js.</span>
<span class="cm">             *</span>
<span class="cm">             * @property modules</span>
<span class="cm">             * @type Array</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">modules</span> <span class="o">=</span> <span class="p">[];</span>

            <span class="cm">/**</span>
<span class="cm">             * Contains references to all connectors on the page.</span>
<span class="cm">             *</span>
<span class="cm">             * @property connectors</span>
<span class="cm">             * @type Object</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">connectors</span> <span class="o">=</span> <span class="p">{};</span>

            <span class="cm">/**</span>
<span class="cm">             * Contains references to all wilcard components on the page.</span>
<span class="cm">             *</span>
<span class="cm">             * @property wildcardComponents</span>
<span class="cm">             * @type Array</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">wildcardComponents</span> <span class="o">=</span> <span class="p">[];</span>

            <span class="cm">/**</span>
<span class="cm">             * The sandbox to get the resources from (shared between all modules).</span>
<span class="cm">             *</span>
<span class="cm">             * @property sandbox</span>
<span class="cm">             * @type Sandbox</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">sandbox</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Tc</span><span class="p">.</span><span class="nx">Sandbox</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">config</span><span class="p">);</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Registers all modules in the context scope automatically (as long as the modules uses the oocss naming conventions).</span>
<span class="cm">         *</span>
<span class="cm">         * @method registerModules</span>
<span class="cm">         * @param {jQuery} $ctx the jquery context.</span>
<span class="cm">         * @return {Array} a list containing the references of the registered modules.</span>
<span class="cm">         */</span>
        <span class="nx">registerModules</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$ctx</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">,</span>
                    <span class="nx">modules</span> <span class="o">=</span> <span class="p">[];</span>

            <span class="nx">$ctx</span> <span class="o">=</span> <span class="nx">$ctx</span> <span class="o">||</span> <span class="k">this</span><span class="p">.</span><span class="nx">$ctx</span><span class="p">;</span>

            <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;.mod&#39;</span><span class="p">,</span> <span class="nx">$ctx</span><span class="p">).</span><span class="nx">each</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                <span class="kd">var</span> <span class="nx">$this</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

                <span class="cm">/*</span>
<span class="cm">                 * a module can have 3 types of classes:</span>
<span class="cm">                 * 1. .mod -&gt; indicates that it is a base module (default -&gt; no javascript need to be involved)</span>
<span class="cm">                 * 2. .mod&lt;moduleName&gt; (ie. .modBasic) -&gt; indicates that it is a module from the type basic (derived from the base module)</span>
<span class="cm">                 * 3. .skin&lt;moduleName&gt;&lt;skinName&gt; (ie. .skinBasicSubmarine) -&gt; indicates that the module basic has the submarine skin. it will be decorated by the skin js (if existing).</span>
<span class="cm">                 *</span>
<span class="cm">                 * type 1 must occur exactly once</span>
<span class="cm">                 * type 2 can occur at most once</span>
<span class="cm">                 * type 3 can occur arbitrarily</span>
<span class="cm">                 *</span>
<span class="cm">                 * additionaly a module can have 1 type of data attributes:</span>
<span class="cm">                 * 1. data-connectors -&gt; a comma separated value containing the connector ids -&gt; schema of a connector id: &lt;connectorName&gt;&lt;connectorId&gt;&lt;connectorRole&gt;</span>
<span class="cm">                 *    (ie. MasterSlave1Master -&gt; name = MasterSlave, id = 1, role = Master)</span>
<span class="cm">                 * 	-&gt; indicates that the module should notify the MasterSlave connector (mediator) over all state changes</span>
<span class="cm">                 * 	-&gt; the connector id is used to chain the appropriate modules together and to improve the reusability of the connector</span>
<span class="cm">                 *</span>
<span class="cm">                 * type 1 can contain multiple connector ids (ie. 1,2,MasterSlave1Master)</span>
<span class="cm">                 */</span>

                <span class="kd">var</span> <span class="nx">classes</span> <span class="o">=</span> <span class="nx">$this</span><span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;class&#39;</span><span class="p">).</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">);</span>

                <span class="k">if</span> <span class="p">(</span><span class="nx">classes</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="kd">var</span> <span class="nx">modName</span><span class="p">,</span>
                            <span class="nx">skins</span> <span class="o">=</span> <span class="p">[],</span>
                            <span class="nx">connectors</span> <span class="o">=</span> <span class="p">[];</span>

                    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">classes</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                        <span class="kd">var</span> <span class="nx">part</span> <span class="o">=</span> <span class="nx">$</span><span class="p">.</span><span class="nx">trim</span><span class="p">(</span><span class="nx">classes</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>

                        <span class="k">if</span> <span class="p">(</span><span class="nx">part</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s1">&#39;mod&#39;</span><span class="p">)</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">part</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
                            <span class="nx">modName</span> <span class="o">=</span> <span class="nx">part</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
                        <span class="p">}</span>
                        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">part</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s1">&#39;skin&#39;</span><span class="p">)</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                            <span class="c1">// remove the mod name part from the skin name</span>
                            <span class="nx">skins</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">part</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">4</span><span class="p">).</span><span class="nx">replace</span><span class="p">(</span><span class="nx">modName</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">));</span>
                        <span class="p">}</span>
                    <span class="p">}</span>


                    <span class="k">if</span> <span class="p">(</span><span class="nx">$this</span><span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;data-connectors&#39;</span><span class="p">))</span> <span class="p">{</span>
                        <span class="nx">connectors</span> <span class="o">=</span> <span class="nx">$this</span><span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;data-connectors&#39;</span><span class="p">).</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">);</span>
                        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">connectors</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                            <span class="nx">connectors</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">$</span><span class="p">.</span><span class="nx">trim</span><span class="p">(</span><span class="nx">connectors</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
                        <span class="p">}</span>
                    <span class="p">}</span>


                    <span class="k">if</span> <span class="p">(</span><span class="nx">modName</span> <span class="o">&amp;&amp;</span> <span class="nx">Tc</span><span class="p">.</span><span class="nx">Module</span><span class="p">[</span><span class="nx">modName</span><span class="p">])</span> <span class="p">{</span>
                        <span class="nx">modules</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="nx">registerModule</span><span class="p">(</span><span class="nx">$this</span><span class="p">,</span> <span class="nx">modName</span><span class="p">,</span> <span class="nx">skins</span><span class="p">,</span> <span class="nx">connectors</span><span class="p">));</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">});</span>

            <span class="k">return</span> <span class="nx">modules</span><span class="p">;</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Unregisters the modules by the given module instances.</span>
<span class="cm">         *</span>
<span class="cm">         * @method unregisterModule</span>
<span class="cm">         * @param {Array} modules a list containting the module instances to unregister.</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">unregisterModules</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">modules</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">connectors</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">connectors</span><span class="p">,</span>
                    <span class="nx">wildcardComponents</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">wildcardComponents</span><span class="p">;</span>

            <span class="nx">modules</span> <span class="o">=</span> <span class="nx">modules</span> <span class="o">||</span> <span class="k">this</span><span class="p">.</span><span class="nx">modules</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="nx">modules</span> <span class="o">===</span> <span class="k">this</span><span class="p">.</span><span class="nx">modules</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// empy everything if the arrays are equal</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">wildcardComponents</span> <span class="o">=</span> <span class="p">[];</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">connectors</span> <span class="o">=</span> <span class="p">[];</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">modules</span> <span class="o">=</span> <span class="p">[];</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// unregister the given modules</span>
                <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">modules</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="kd">var</span> <span class="nx">module</span> <span class="o">=</span> <span class="nx">modules</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
                    <span class="kd">var</span> <span class="nx">index</span><span class="p">;</span>

                    <span class="c1">// delete the references in the connectors</span>
                    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">connId</span> <span class="k">in</span> <span class="nx">connectors</span><span class="p">)</span> <span class="p">{</span>
                        <span class="nx">connectors</span><span class="p">[</span><span class="nx">connId</span><span class="p">].</span><span class="nx">unregisterComponent</span><span class="p">(</span><span class="nx">module</span><span class="p">);</span>
                    <span class="p">}</span>

                    <span class="c1">// delete the references in the wildcard components</span>
                    <span class="nx">index</span> <span class="o">=</span> <span class="nx">$</span><span class="p">.</span><span class="nx">inArray</span><span class="p">(</span><span class="nx">module</span><span class="p">,</span> <span class="nx">wildcardComponents</span><span class="p">);</span>
                    <span class="k">delete</span> <span class="nx">wildcardComponents</span><span class="p">[</span><span class="nx">index</span><span class="p">];</span>

                    <span class="c1">// delete the module instance itself</span>
                    <span class="nx">index</span> <span class="o">=</span> <span class="nx">$</span><span class="p">.</span><span class="nx">inArray</span><span class="p">(</span><span class="nx">module</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">modules</span><span class="p">);</span>
                    <span class="k">delete</span> <span class="k">this</span><span class="p">.</span><span class="nx">modules</span><span class="p">[</span><span class="nx">index</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Starts (intializes) the registered modules.</span>
<span class="cm">         *</span>
<span class="cm">         * @method start</span>
<span class="cm">         * @param {Array} modules a list of the modules to start.</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">start</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">modules</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">wildcardComponents</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">wildcardComponents</span><span class="p">,</span>
                    <span class="nx">connectors</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">connectors</span><span class="p">;</span>

            <span class="nx">modules</span> <span class="o">=</span> <span class="nx">modules</span> <span class="o">||</span> <span class="k">this</span><span class="p">.</span><span class="nx">modules</span><span class="p">;</span>

            <span class="c1">// start the modules</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">modules</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">modules</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">start</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="cm">/*</span>
<span class="cm">             * special treatment for the wildcard connection (conn*) -&gt; it will be notified about</span>
<span class="cm">             * all state changes from all connections and is able to propagate its changes to all modules.</span>
<span class="cm">             * this must be done on init to make sure that all connectors on the page has been instantiated.</span>
<span class="cm">             * only do this for the given modules.</span>
<span class="cm">             */</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">wildcardComponents</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kd">var</span> <span class="nx">component</span> <span class="o">=</span> <span class="nx">wildcardComponents</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">$</span><span class="p">.</span><span class="nx">inArray</span><span class="p">(</span><span class="nx">component</span><span class="p">,</span> <span class="nx">modules</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">connectorId</span> <span class="k">in</span> <span class="nx">connectors</span><span class="p">)</span> <span class="p">{</span>
                        <span class="c1">// the connector observes the component -&gt; attach it as observer</span>
                        <span class="nx">component</span><span class="p">.</span><span class="nx">attachConnector</span><span class="p">(</span><span class="nx">connectors</span><span class="p">[</span><span class="nx">connectorId</span><span class="p">]);</span>
                        <span class="nx">connectors</span><span class="p">[</span><span class="nx">connectorId</span><span class="p">].</span><span class="nx">registerComponent</span><span class="p">(</span><span class="nx">component</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Stops the registered modules.</span>
<span class="cm">         *</span>
<span class="cm">         * @method stop</span>
<span class="cm">         * @param {Array} modules a list containting the module instances to stop.</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">stop</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">modules</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">modules</span> <span class="o">=</span> <span class="nx">modules</span> <span class="o">||</span> <span class="k">this</span><span class="p">.</span><span class="nx">modules</span><span class="p">;</span>

            <span class="c1">// stop the modules</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">modules</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">modules</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">stop</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Registers a module.</span>
<span class="cm">         *</span>
<span class="cm">         * @method registerModule</span>
<span class="cm">         * @param {jQuery} $node the module node.</span>
<span class="cm">         * @param {String} modName the module name. it must match the class name of the module (case sensitive).</span>
<span class="cm">         * @param {Array} skins a list of skin names. each entry must match a class name of a skin (case sensitive)).</span>
<span class="cm">         * @param {Array} connectors a list of connectors identifiers. schema: &lt;connectorName&gt;&lt;connectorId&gt;&lt;connectorRole&gt; (ie. MasterSlave1Master).</span>
<span class="cm">         * @return {Module} the reference to the registered module.</span>
<span class="cm">         */</span>
        <span class="nx">registerModule</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$node</span><span class="p">,</span> <span class="nx">modName</span><span class="p">,</span> <span class="nx">skins</span><span class="p">,</span> <span class="nx">connectors</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">modules</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">modules</span><span class="p">;</span>

            <span class="nx">modName</span> <span class="o">=</span> <span class="nx">modName</span> <span class="o">||</span> <span class="kc">null</span><span class="p">;</span>
            <span class="nx">skins</span> <span class="o">=</span> <span class="nx">skins</span> <span class="o">||</span> <span class="p">[];</span>
            <span class="nx">connectors</span> <span class="o">=</span> <span class="nx">connectors</span> <span class="o">||</span> <span class="p">[];</span>

            <span class="k">if</span> <span class="p">(</span><span class="nx">modName</span> <span class="o">&amp;&amp;</span> <span class="nx">Tc</span><span class="p">.</span><span class="nx">Module</span><span class="p">[</span><span class="nx">modName</span><span class="p">])</span> <span class="p">{</span>
                <span class="c1">// generate a unique id for every module</span>
                <span class="kd">var</span> <span class="nx">modId</span> <span class="o">=</span> <span class="nx">modules</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
                <span class="nx">$node</span><span class="p">.</span><span class="nx">data</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="nx">modId</span><span class="p">);</span>

                
                <span class="nx">modules</span><span class="p">[</span><span class="nx">modId</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Tc</span><span class="p">.</span><span class="nx">Module</span><span class="p">[</span><span class="nx">modName</span><span class="p">](</span><span class="nx">$node</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">sandbox</span><span class="p">,</span> <span class="nx">modId</span><span class="p">);</span>

                <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">skins</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="kd">var</span> <span class="nx">skinName</span> <span class="o">=</span> <span class="nx">skins</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>

                    <span class="k">if</span> <span class="p">(</span><span class="nx">Tc</span><span class="p">.</span><span class="nx">Module</span><span class="p">[</span><span class="nx">modName</span><span class="p">][</span><span class="nx">skinName</span><span class="p">])</span> <span class="p">{</span>
                        
                        <span class="nx">modules</span><span class="p">[</span><span class="nx">modId</span><span class="p">]</span> <span class="o">=</span> <span class="nx">modules</span><span class="p">[</span><span class="nx">modId</span><span class="p">].</span><span class="nx">getDecoratedModule</span><span class="p">(</span><span class="nx">modName</span><span class="p">,</span> <span class="nx">skinName</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">connectors</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">this</span><span class="p">.</span><span class="nx">registerConnection</span><span class="p">(</span><span class="nx">connectors</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">modules</span><span class="p">[</span><span class="nx">modId</span><span class="p">]);</span>
                <span class="p">}</span>

                <span class="k">return</span> <span class="nx">modules</span><span class="p">[</span><span class="nx">modId</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                
                <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Registers a connection between a module and a connector.</span>
<span class="cm">         *</span>
<span class="cm">         * @method registerConnection</span>
<span class="cm">         * @param {String} connector the full connector name (ie. MasterSlave1Slave).</span>
<span class="cm">         * @param {Module} component the module instance.</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">registerConnection</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">connector</span><span class="p">,</span> <span class="nx">component</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">connectorType</span> <span class="o">=</span> <span class="nx">connector</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/[0-9]+[a-zA-Z]*$/</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span>
                    <span class="nx">connectorId</span> <span class="o">=</span> <span class="nx">connector</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/[a-zA-Z]*$/</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">).</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/^[a-zA-Z]*/</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span>
                    <span class="nx">connectorRole</span> <span class="o">=</span> <span class="nx">connector</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/^[a-zA-Z]*[0-9]*/</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="nx">connectorId</span> <span class="o">===</span> <span class="s1">&#39;*&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">connectorRole</span> <span class="o">===</span> <span class="s1">&#39;*&#39;</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// add the component to the wildcard component stack</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">wildcardComponents</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">component</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="kd">var</span> <span class="nx">connectors</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">connectors</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">connectors</span><span class="p">[</span><span class="nx">connectorId</span><span class="p">])</span> <span class="p">{</span>
                    <span class="c1">// instantiate the appropriate connector if it does not exist yet</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nx">connectorType</span> <span class="o">===</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="p">{</span>
                        <span class="nx">connectors</span><span class="p">[</span><span class="nx">connectorId</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Tc</span><span class="p">.</span><span class="nx">Connector</span><span class="p">(</span><span class="nx">connectorId</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">Tc</span><span class="p">.</span><span class="nx">Connector</span><span class="p">[</span><span class="nx">connectorType</span><span class="p">])</span> <span class="p">{</span>
                        <span class="nx">connectors</span><span class="p">[</span><span class="nx">connectorId</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Tc</span><span class="p">.</span><span class="nx">Connector</span><span class="p">[</span><span class="nx">connectorType</span><span class="p">](</span><span class="nx">connectorId</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="p">(</span><span class="nx">connectors</span><span class="p">[</span><span class="nx">connectorId</span><span class="p">])</span> <span class="p">{</span>
                    

                    <span class="c1">// the connector observes the component -&gt; attach it as observer</span>
                    <span class="nx">component</span><span class="p">.</span><span class="nx">attachConnector</span><span class="p">(</span><span class="nx">connectors</span><span class="p">[</span><span class="nx">connectorId</span><span class="p">]);</span>

                    <span class="c1">// the component wants to be informed over state changes -&gt; register it as connector member</span>
                    <span class="nx">connectors</span><span class="p">[</span><span class="nx">connectorId</span><span class="p">].</span><span class="nx">registerComponent</span><span class="p">(</span><span class="nx">component</span><span class="p">,</span> <span class="nx">connectorRole</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">})(</span><span class="nx">Tc</span><span class="p">.</span><span class="nx">$</span><span class="p">);</span>

<span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">$</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/**</span>
<span class="cm">     * The sandbox is used as a central point to get resources from / grant permissions etc.</span>
<span class="cm">     * It is shared between all modules.</span>
<span class="cm">     *</span>
<span class="cm">     * @author Remo Brunschwiler</span>
<span class="cm">     * @namespace Tc</span>
<span class="cm">     * @class Sandbox</span>
<span class="cm">     */</span>
    <span class="nx">Tc</span><span class="p">.</span><span class="nx">Sandbox</span> <span class="o">=</span> <span class="nx">Class</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
		
		<span class="cm">/**</span>
<span class="cm">		 * Initializes the Sandbox.</span>
<span class="cm">		 * </span>
<span class="cm">		 * @method init</span>
<span class="cm">		 * @return {void}</span>
<span class="cm">		 * @constructor</span>
<span class="cm">	     * @param {Applicaton} application the application reference</span>
<span class="cm">	     * @param {Object} config the configuration</span>
<span class="cm">		 */</span>
		<span class="nx">init</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">application</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
	    
	        <span class="cm">/** </span>
<span class="cm">	         * The application</span>
<span class="cm">	         *</span>
<span class="cm">	         * @property application</span>
<span class="cm">	         * @type Application</span>
<span class="cm">	         */</span>
	        <span class="k">this</span><span class="p">.</span><span class="nx">application</span> <span class="o">=</span> <span class="nx">application</span><span class="p">;</span>
	        
	        <span class="cm">/** </span>
<span class="cm">	         * The configuration.</span>
<span class="cm">	         *</span>
<span class="cm">	         * @property config</span>
<span class="cm">	         * @type Object</span>
<span class="cm">	         */</span>
	        <span class="k">this</span><span class="p">.</span><span class="nx">config</span> <span class="o">=</span> <span class="nx">config</span><span class="p">;</span>
	        
	        <span class="cm">/**</span>
<span class="cm">	         * Contains the requested javascript dependencies.</span>
<span class="cm">	         *</span>
<span class="cm">	         * @property dependencies</span>
<span class="cm">	         * @type Array</span>
<span class="cm">	         */</span>
	        <span class="k">this</span><span class="p">.</span><span class="nx">dependencies</span> <span class="o">=</span> <span class="p">[];</span>
	        
	        <span class="cm">/**</span>
<span class="cm">	         * Contains the afterBinding module callbacks.</span>
<span class="cm">	         *</span>
<span class="cm">	         * @property afterBindingCallbacks</span>
<span class="cm">	         * @type Array</span>
<span class="cm">	         */</span>
	        <span class="k">this</span><span class="p">.</span><span class="nx">afterBindingCallbacks</span> <span class="o">=</span> <span class="p">[];</span>
	    <span class="p">},</span>
    
		<span class="cm">/**</span>
<span class="cm">		 * Adds (register and start) all modules in the given context scope.</span>
<span class="cm">		 * </span>
<span class="cm">		 * @method addModules</span>
<span class="cm">		 * @param {jQuery} $ctx the jquery context.</span>
<span class="cm">		 * @return {Array} a list containing the references of the registered modules.</span>
<span class="cm">		 */</span>
		<span class="nx">addModules</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$ctx</span><span class="p">)</span> <span class="p">{</span>
			<span class="kd">var</span> <span class="nx">modules</span> <span class="o">=</span> <span class="p">[],</span>
                <span class="nx">application</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">application</span><span class="p">;</span>
			
			<span class="k">if</span><span class="p">(</span><span class="nx">$ctx</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// reset lazyinit flags</span>
                <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;.mod[data-lazyinit=true]&#39;</span><span class="p">,</span> <span class="nx">$ctx</span><span class="p">).</span><span class="nx">removeAttr</span><span class="p">(</span><span class="s1">&#39;data-lazyinit&#39;</span><span class="p">);</span>

				<span class="c1">// register modules</span>
				<span class="nx">modules</span> <span class="o">=</span> <span class="nx">application</span><span class="p">.</span><span class="nx">registerModules</span><span class="p">(</span><span class="nx">$ctx</span><span class="p">);</span>
			
				<span class="c1">// start modules</span>
				<span class="nx">application</span><span class="p">.</span><span class="nx">start</span><span class="p">(</span><span class="nx">modules</span><span class="p">);</span>
			<span class="p">}</span> 
			
			<span class="k">return</span> <span class="nx">modules</span><span class="p">;</span>
		<span class="p">},</span>
		
		<span class="cm">/**</span>
<span class="cm">		 * Removes (stop and unregister) the modules by the given module instances.</span>
<span class="cm">		 * </span>
<span class="cm">		 * @method removeModules</span>
<span class="cm">		 * @param {Array} modules a list containting the module instances to remove.</span>
<span class="cm">		 * @return {void}</span>
<span class="cm">		 */</span>
		<span class="nx">removeModules</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">modules</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">application</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">application</span><span class="p">;</span>
            
			<span class="k">if</span> <span class="p">(</span><span class="nx">modules</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// stop modules </span>
				<span class="nx">application</span><span class="p">.</span><span class="nx">stop</span><span class="p">(</span><span class="nx">modules</span><span class="p">);</span>
				
				<span class="c1">// unregister modules</span>
				<span class="nx">application</span><span class="p">.</span><span class="nx">unregisterModules</span><span class="p">(</span><span class="nx">modules</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Gets the appropriate module for the given id.</span>
<span class="cm">         *</span>
<span class="cm">         * @method getModuleById</span>
<span class="cm">         * @param {int} id the module id</span>
<span class="cm">         * @return {Module} the appropriate module</span>
<span class="cm">         */</span>
        <span class="nx">getModuleById</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">application</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">application</span><span class="p">;</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="nx">application</span><span class="p">.</span><span class="nx">modules</span><span class="p">[</span><span class="nx">id</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">application</span><span class="p">.</span><span class="nx">modules</span><span class="p">[</span><span class="nx">id</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;the module with the id &#39;</span> <span class="o">+</span> <span class="nx">id</span> <span class="o">+</span> <span class="s1">&#39; does not exist&#39;</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Gets the application config.</span>
<span class="cm">         *</span>
<span class="cm">         * @method getConfig</span>
<span class="cm">         * @return {Object} the configuration object</span>
<span class="cm">         */</span>
        <span class="nx">getConfig</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">config</span><span class="p">;</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Gets an application config param.</span>
<span class="cm">         *</span>
<span class="cm">         * @method getConfigParam</span>
<span class="cm">         * @param {String} name the param name</span>
<span class="cm">         * @return {mixed} the appropriate configuration param</span>
<span class="cm">         */</span>
        <span class="nx">getConfigParam</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">config</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">config</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">name</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">config</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;the config param &#39;</span> <span class="o">+</span> <span class="nx">name</span> <span class="o">+</span> <span class="s1">&#39; does not exist&#39;</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">},</span>
		
        <span class="cm">/**</span>
<span class="cm">         * Loads a requested dependency (if not already loaded).</span>
<span class="cm">         *</span>
<span class="cm">         * @method loadDependency</span>
<span class="cm">         * @param {String} dependency the dependency (i.e. swfobject.js)</span>
<span class="cm">         * @param {String} type the dependency type (plugin | library | util | url)</span>
<span class="cm">         * @param {Function} callback the callback to execute after the dependency has successfully loaded</span>
<span class="cm">         * @param {String} phase the module phase where the dependency is needed (ie. beforeBinding, onBinding)</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">loadDependency</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">dependency</span><span class="p">,</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">callback</span><span class="p">,</span> <span class="nx">phase</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
            
            <span class="nx">phase</span> <span class="o">=</span> <span class="nx">phase</span> <span class="o">||</span> <span class="s1">&#39;none&#39;</span><span class="p">;</span> <span class="c1">// none indicates that it is not a dependency for a specific phase</span>
            <span class="nx">type</span> <span class="o">=</span> <span class="nx">type</span> <span class="o">||</span> <span class="s1">&#39;plugin&#39;</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="nx">dependencies</span><span class="p">[</span><span class="nx">dependency</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">that</span><span class="p">.</span><span class="nx">dependencies</span><span class="p">[</span><span class="nx">dependency</span><span class="p">].</span><span class="nx">state</span> <span class="o">===</span> <span class="s1">&#39;requested&#39;</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// requested (but loading not finished)</span>
                
                
                <span class="c1">// the module should be notified, if the dependency has loaded</span>
                <span class="nx">that</span><span class="p">.</span><span class="nx">dependencies</span><span class="p">[</span><span class="nx">dependency</span><span class="p">].</span><span class="nx">callbacks</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nx">callback</span><span class="p">(</span><span class="nx">phase</span><span class="p">);</span>
                <span class="p">});</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="nx">dependencies</span><span class="p">[</span><span class="nx">dependency</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">that</span><span class="p">.</span><span class="nx">dependencies</span><span class="p">[</span><span class="nx">dependency</span><span class="p">].</span><span class="nx">state</span> <span class="o">===</span> <span class="s1">&#39;loaded&#39;</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// loading finished</span>
                
                <span class="nx">callback</span><span class="p">(</span><span class="nx">phase</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                
                <span class="nx">that</span><span class="p">.</span><span class="nx">dependencies</span><span class="p">[</span><span class="nx">dependency</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="nx">state</span><span class="o">:</span> <span class="s1">&#39;requested&#39;</span><span class="p">,</span>
                    <span class="nx">callbacks</span><span class="o">:</span> <span class="p">[]</span>
                <span class="p">};</span>
                
                <span class="kd">var</span> <span class="nx">path</span><span class="p">;</span>
                
                <span class="k">switch</span> <span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">case</span> <span class="s1">&#39;library&#39;</span><span class="o">:</span>
                    <span class="k">case</span> <span class="s1">&#39;plugin&#39;</span><span class="o">:</span>
                    <span class="k">case</span> <span class="s1">&#39;util&#39;</span><span class="o">:</span>
                        <span class="nx">path</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">dependencyPath</span><span class="p">[</span><span class="nx">type</span><span class="p">];</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="s1">&#39;url&#39;</span><span class="o">:</span>
                        <span class="nx">path</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="s1">&#39;default&#39;</span><span class="o">:</span>
                        
                        <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                
                <span class="c1">// load the appropriate dependency</span>
                <span class="nx">$</span><span class="p">.</span><span class="nx">ajax</span><span class="p">({</span>
                    <span class="nx">url</span><span class="o">:</span> <span class="s1">&#39;&#39;</span> <span class="o">+</span> <span class="nx">path</span> <span class="o">+</span> <span class="nx">dependency</span><span class="p">,</span>
                    <span class="nx">dataType</span><span class="o">:</span> <span class="s1">&#39;script&#39;</span><span class="p">,</span>
                    <span class="nx">cache</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
                    <span class="nx">success</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                        
                        <span class="nx">that</span><span class="p">.</span><span class="nx">dependencies</span><span class="p">[</span><span class="nx">dependency</span><span class="p">].</span><span class="nx">state</span> <span class="o">=</span> <span class="s1">&#39;loaded&#39;</span><span class="p">;</span>
                        <span class="nx">callback</span><span class="p">(</span><span class="nx">phase</span><span class="p">);</span>
                        
                        <span class="c1">// notify the other modules with this dependency</span>
                        <span class="kd">var</span> <span class="nx">callbacks</span> <span class="o">=</span> <span class="nx">that</span><span class="p">.</span><span class="nx">dependencies</span><span class="p">[</span><span class="nx">dependency</span><span class="p">].</span><span class="nx">callbacks</span><span class="p">;</span>
                        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">callbacks</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                            <span class="nx">callbacks</span><span class="p">[</span><span class="nx">i</span><span class="p">]();</span>
                        <span class="p">}</span>
                    <span class="p">},</span>
                    <span class="nx">error</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                        
                    <span class="p">}</span>
                <span class="p">});</span>
            <span class="p">}</span>
        <span class="p">},</span>
        
        <span class="cm">/**</span>
<span class="cm">         * Collects the module status messages (ready for after binding) and handles the callbacks.</span>
<span class="cm">         *</span>
<span class="cm">         * @method readyForAfterBinding</span>
<span class="cm">         * @param {Function} callback the afterBinding module callback</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">readyForAfterBinding</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">afterBindingCallbacks</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">afterBindingCallbacks</span><span class="p">;</span>
            
            <span class="c1">// add the callback to the stack</span>
            <span class="nx">afterBindingCallbacks</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">callback</span><span class="p">);</span>
            
            <span class="c1">// check whether all modules are ready for the after binding phase</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">application</span><span class="p">.</span><span class="nx">modules</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="nx">afterBindingCallbacks</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">afterBindingCallbacks</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">afterBindingCallbacks</span><span class="p">[</span><span class="nx">i</span><span class="p">]();</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">})(</span><span class="nx">Tc</span><span class="p">.</span><span class="nx">$</span><span class="p">);</span>

<span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">$</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/**</span>
<span class="cm">     * Base class for the different modules.</span>
<span class="cm">     *</span>
<span class="cm">     * @author Remo Brunschwiler</span>
<span class="cm">     * @namespace Tc</span>
<span class="cm">     * @class Module</span>
<span class="cm">     */</span>
    <span class="nx">Tc</span><span class="p">.</span><span class="nx">Module</span> <span class="o">=</span> <span class="nx">Class</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>

        <span class="cm">/**</span>
<span class="cm">         * Initializes the Module.</span>
<span class="cm">         *</span>
<span class="cm">         * @method init</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         * @constructor</span>
<span class="cm">         * @param {jQuery} $ctx the jquery context</span>
<span class="cm">         * @param {Sandbox} sandbox the sandbox to get the resources from</span>
<span class="cm">         * @param {String} modId the unique module id</span>
<span class="cm">         */</span>
        <span class="nx">init</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$ctx</span><span class="p">,</span> <span class="nx">sandbox</span><span class="p">,</span> <span class="nx">modId</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/**</span>
<span class="cm">             * Contains the module context.</span>
<span class="cm">             *</span>
<span class="cm">             * @property $ctx</span>
<span class="cm">             * @type jQuery</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">$ctx</span> <span class="o">=</span> <span class="nx">$ctx</span><span class="p">;</span>

            <span class="cm">/**</span>
<span class="cm">             * Contains the unique module id.</span>
<span class="cm">             *</span>
<span class="cm">             * @property modId</span>
<span class="cm">             * @type String</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">modId</span> <span class="o">=</span> <span class="nx">modId</span><span class="p">;</span>

            <span class="cm">/**</span>
<span class="cm">             * Contains the attached connectors.</span>
<span class="cm">             *</span>
<span class="cm">             * @property connectors</span>
<span class="cm">             * @type Array</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">connectors</span> <span class="o">=</span> <span class="p">[];</span>

            <span class="cm">/**</span>
<span class="cm">             * Contains the dependency counter for the different phases.</span>
<span class="cm">             *</span>
<span class="cm">             * @property dependencyCounter</span>
<span class="cm">             * @type Object</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">dependencyCounter</span> <span class="o">=</span> <span class="p">{</span>
                <span class="nx">beforeBinding</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
                <span class="nx">onBinding</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">// not 0, because of the beforeBinding callback (which is also a dependency)</span>
                <span class="nx">afterBinding</span><span class="o">:</span> <span class="mi">0</span>
            <span class="p">};</span>

            <span class="cm">/**</span>
<span class="cm">             * The sandbox to get the resources from.</span>
<span class="cm">             *</span>
<span class="cm">             * @property sandbox</span>
<span class="cm">             * @type Sandbox</span>
<span class="cm">             */</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">sandbox</span> <span class="o">=</span> <span class="nx">sandbox</span><span class="p">;</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Template method to start (init) the module.</span>
<span class="cm">         * This method provides some hook functions which could be overridden from the concrete implementation</span>
<span class="cm">         *</span>
<span class="cm">         * @method start</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">start</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>

            <span class="c1">// call the hook method dependecies from the concrete implementation</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">dependencies</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">dependencyCounter</span><span class="p">.</span><span class="nx">beforeBinding</span><span class="o">++</span><span class="p">;</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">dependencies</span><span class="p">();</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">dependencyCounter</span><span class="p">.</span><span class="nx">beforeBinding</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// start the before binding phase if there are no dependency for this phase</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">checkDependencies</span><span class="p">(</span><span class="s1">&#39;beforeBinding&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                <span class="nx">that</span><span class="p">.</span><span class="nx">initBeforeBinding</span><span class="p">();</span>
            <span class="p">});</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Template method to stop the module.</span>
<span class="cm">         *</span>
<span class="cm">         * @method stop</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">stop</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">$ctx</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">$ctx</span><span class="p">;</span>
            
            <span class="c1">// remove all bound events and associated jquery data</span>
            <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="nx">$ctx</span><span class="p">).</span><span class="nx">unbind</span><span class="p">().</span><span class="nx">removeData</span><span class="p">();</span>
            <span class="nx">$ctx</span><span class="p">.</span><span class="nx">unbind</span><span class="p">().</span><span class="nx">removeData</span><span class="p">();</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Initializes the before binding phase.</span>
<span class="cm">         *</span>
<span class="cm">         * @method initBeforeBinding</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">initBeforeBinding</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>

            <span class="c1">// call the hook method beforeBinding from the concrete implementation</span>
            <span class="c1">// because there might be some ajax calls, the bindEvents method must be called from</span>
            <span class="c1">// the beforeBinding function after it has been run</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">beforeBinding</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">beforeBinding</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nx">that</span><span class="p">.</span><span class="nx">beforeBindingCallback</span><span class="p">();</span>
                <span class="p">});</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">beforeBindingCallback</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Callback for the before binding phase.</span>
<span class="cm">         * </span>
<span class="cm">         * @method beforeBindingCallback</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">beforeBindingCallback</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>

            <span class="c1">// decrement the dependency counter for the on binding phase</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">dependencyCounter</span><span class="p">.</span><span class="nx">onBinding</span><span class="o">--</span><span class="p">;</span>

            <span class="c1">// start the on binding phase if there are no dependencies for this phase</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">checkDependencies</span><span class="p">(</span><span class="s1">&#39;onBinding&#39;</span><span class="p">,</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                <span class="nx">that</span><span class="p">.</span><span class="nx">initOnBinding</span><span class="p">();</span>
            <span class="p">});</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Initializes the on binding phase.</span>
<span class="cm">         *</span>
<span class="cm">         * @method initOnBinding</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">initOnBinding</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>

            <span class="c1">// call the hook method bindEvents from the concrete implementation</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">onBinding</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">onBinding</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="c1">// start the after binding phase if there are no dependencies for this phase</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">checkDependencies</span><span class="p">(</span><span class="s1">&#39;afterBinding&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                <span class="nx">that</span><span class="p">.</span><span class="nx">initAfterBinding</span><span class="p">();</span>
            <span class="p">});</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Initializes the after binding phase.</span>
<span class="cm">         *</span>
<span class="cm">         * @method initAfterBinding</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">initAfterBinding</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>

            <span class="c1">// inform the sandbox that the module is ready for the after binding phase</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">sandbox</span><span class="p">.</span><span class="nx">readyForAfterBinding</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

                <span class="c1">// call the hook method afterBinding from the concrete implementation</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="nx">afterBinding</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">that</span><span class="p">.</span><span class="nx">afterBinding</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">});</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Checks the dependency load state of the given phase.</span>
<span class="cm">         * Initializes the appropriate phase if all dependencies are loaded.</span>
<span class="cm">         *</span>
<span class="cm">         * @method checkDependencies</span>
<span class="cm">         * @param {String} phase the phase to check / initialize</span>
<span class="cm">         * @param {Function} callback the callback to execute if all dependencies were loaded</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">checkDependencies</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">phase</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">dependencyCounter</span><span class="p">[</span><span class="nx">phase</span><span class="p">]</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// execute the callback</span>
                <span class="nx">callback</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Manages the required dependencies.</span>
<span class="cm">         *</span>
<span class="cm">         * @method require</span>
<span class="cm">         * @param {String} dependency the dependency (i.e. swfobject.js)</span>
<span class="cm">         * @param {String} type the dependency type (library | plugin | util | url)</span>
<span class="cm">         * @param {String} phase the module phase where the dependency is needed (ie. beforeBinding, onBinding)</span>
<span class="cm">         * @param {boolean} executeCallback indicates whether the phase callback should be executed or not (useful for dependencies that provide their own callback mechanism)</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">require</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">dependency</span><span class="p">,</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">phase</span><span class="p">,</span> <span class="nx">executeCallback</span><span class="p">)</span> <span class="p">{</span>
            
            <span class="nx">type</span> <span class="o">=</span> <span class="nx">type</span> <span class="o">||</span> <span class="s1">&#39;plugin&#39;</span><span class="p">;</span>
            <span class="nx">phase</span> <span class="o">=</span> <span class="nx">phase</span> <span class="o">||</span> <span class="s1">&#39;onBinding&#39;</span><span class="p">;</span>
            <span class="nx">executeCallback</span> <span class="o">=</span> <span class="nx">executeCallback</span> <span class="o">===</span> <span class="kc">false</span> <span class="o">?</span> <span class="kc">false</span> <span class="o">:</span> <span class="kc">true</span><span class="p">;</span>

            <span class="c1">// increment the dependency counter</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">dependencyCounter</span><span class="p">[</span><span class="nx">phase</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>

            <span class="c1">// proxy the callback to the outermost decorator</span>
            <span class="kd">var</span> <span class="nx">callback</span> <span class="o">=</span> <span class="nx">$</span><span class="p">.</span><span class="nx">proxy</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">executeCallback</span><span class="p">)</span> <span class="p">{</span>
                    <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>

                    <span class="c1">// decrement the dependency counter for the appropriate phase</span>
                    <span class="k">this</span><span class="p">.</span><span class="nx">dependencyCounter</span><span class="p">[</span><span class="nx">phase</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
                    <span class="k">this</span><span class="p">.</span><span class="nx">checkDependencies</span><span class="p">(</span><span class="nx">phase</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                        <span class="nx">that</span><span class="p">[</span><span class="s1">&#39;init&#39;</span> <span class="o">+</span> <span class="nx">Tc</span><span class="p">.</span><span class="nx">Utils</span><span class="p">.</span><span class="nb">String</span><span class="p">.</span><span class="nx">capitalize</span><span class="p">(</span><span class="nx">phase</span><span class="p">)]();</span>
                    <span class="p">});</span>
                <span class="p">}</span>
            <span class="p">},</span> <span class="k">this</span><span class="p">.</span><span class="nx">sandbox</span><span class="p">.</span><span class="nx">getModuleById</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">modId</span><span class="p">));</span>

            <span class="k">this</span><span class="p">.</span><span class="nx">sandbox</span><span class="p">.</span><span class="nx">loadDependency</span><span class="p">(</span><span class="nx">dependency</span><span class="p">,</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">callback</span><span class="p">,</span> <span class="nx">phase</span><span class="p">);</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Notifies all attached connectors about changes.</span>
<span class="cm">         *</span>
<span class="cm">         * @method fire</span>
<span class="cm">         * @param {String} state the new state</span>
<span class="cm">         * @param {Object} data the data to provide to your connected modules</span>
<span class="cm">         * @param {Function} defaultAction the default action to perform</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">fire</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">defaultAction</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">,</span>
                <span class="nx">connectors</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">connectors</span><span class="p">;</span>
            
            <span class="nx">data</span> <span class="o">=</span> <span class="nx">data</span> <span class="o">||</span><span class="p">{};</span>
            <span class="nx">state</span> <span class="o">=</span> <span class="nx">Tc</span><span class="p">.</span><span class="nx">Utils</span><span class="p">.</span><span class="nb">String</span><span class="p">.</span><span class="nx">capitalize</span><span class="p">(</span><span class="nx">state</span><span class="p">);</span>

            <span class="nx">$</span><span class="p">.</span><span class="nx">each</span><span class="p">(</span><span class="nx">connectors</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                <span class="kd">var</span> <span class="nx">connector</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>

                <span class="c1">// callback combining the defaultAction and the afterAction</span>
                <span class="kd">var</span> <span class="nx">callback</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">defaultAction</span> <span class="o">==</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span>
                        <span class="nx">defaultAction</span><span class="p">();</span>
                    <span class="p">}</span>
                    <span class="nx">connector</span><span class="p">.</span><span class="nx">notify</span><span class="p">(</span><span class="nx">that</span><span class="p">,</span> <span class="s1">&#39;after&#39;</span> <span class="o">+</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">data</span><span class="p">);</span>
                <span class="p">};</span>

                <span class="k">if</span> <span class="p">(</span><span class="nx">connector</span><span class="p">.</span><span class="nx">notify</span><span class="p">(</span><span class="nx">that</span><span class="p">,</span> <span class="s1">&#39;on&#39;</span> <span class="o">+</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">callback</span><span class="p">))</span> <span class="p">{</span>
                    <span class="nx">callback</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">});</span>

            <span class="k">if</span> <span class="p">(</span><span class="nx">connectors</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">defaultAction</span> <span class="o">==</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">defaultAction</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Attaches a connector (observer).</span>
<span class="cm">         *</span>
<span class="cm">         * @method attachConnector</span>
<span class="cm">         * @param {Connector} connector the connector to attach</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">attachConnector</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">connector</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">connectors</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">connector</span><span class="p">);</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Decorates itself with the given skin.</span>
<span class="cm">         *</span>
<span class="cm">         * @method getDecoratedModule</span>
<span class="cm">         * @param {String} module the name of the module</span>
<span class="cm">         * @param {String} skin the name of the skin</span>
<span class="cm">         * @return {Module} the decorated module</span>
<span class="cm">         */</span>
        <span class="nx">getDecoratedModule</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">module</span><span class="p">,</span> <span class="nx">skin</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">Tc</span><span class="p">.</span><span class="nx">Module</span><span class="p">[</span><span class="nx">module</span><span class="p">][</span><span class="nx">skin</span><span class="p">])</span> <span class="p">{</span>
                <span class="kd">var</span> <span class="nx">decorator</span> <span class="o">=</span> <span class="nx">Tc</span><span class="p">.</span><span class="nx">Module</span><span class="p">[</span><span class="nx">module</span><span class="p">][</span><span class="nx">skin</span><span class="p">];</span>

                <span class="cm">/*</span>
<span class="cm">                 * Sets the prototype object to the module.</span>
<span class="cm">                 * So the &quot;non-decorated&quot; functions will be called on the module (without implementing the whole module interface).</span>
<span class="cm">                 */</span>
                <span class="nx">decorator</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
                <span class="nx">decorator</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">Tc</span><span class="p">.</span><span class="nx">Module</span><span class="p">[</span><span class="nx">module</span><span class="p">][</span><span class="nx">skin</span><span class="p">];</span>

                <span class="k">return</span> <span class="k">new</span> <span class="nx">decorator</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                
                <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">})(</span><span class="nx">Tc</span><span class="p">.</span><span class="nx">$</span><span class="p">);</span>

<span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">$</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/**</span>
<span class="cm">     * Base class for the different connectors.</span>
<span class="cm">     *</span>
<span class="cm">     * @author Remo Brunschwiler</span>
<span class="cm">     * @namespace Tc</span>
<span class="cm">     * @class Connector</span>
<span class="cm">     */</span>
    <span class="nx">Tc</span><span class="p">.</span><span class="nx">Connector</span> <span class="o">=</span> <span class="nx">Class</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>

        <span class="cm">/**</span>
<span class="cm">         * Initializes the Connector.</span>
<span class="cm">         *</span>
<span class="cm">         * @method init</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         * @constructor</span>
<span class="cm">         * @param {String} connectorId the unique connector id</span>
<span class="cm">         * @param {Object} connectorId</span>
<span class="cm">         */</span>
        <span class="nx">init</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">connectorId</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">connectorId</span> <span class="o">=</span> <span class="nx">connectorId</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">components</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Registers a component.</span>
<span class="cm">         *</span>
<span class="cm">         * @method registerComponent</span>
<span class="cm">         * @param {Module} component the module to register</span>
<span class="cm">         * @param {String} role the role of the module (ie. master, slave etc.)</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">registerComponent</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">component</span><span class="p">,</span> <span class="nx">role</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">role</span> <span class="o">=</span> <span class="nx">role</span> <span class="o">||</span> <span class="s1">&#39;standard&#39;</span><span class="p">;</span>

            <span class="k">this</span><span class="p">.</span><span class="nx">components</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
                <span class="s1">&#39;component&#39;</span><span class="o">:</span> <span class="nx">component</span><span class="p">,</span>
                <span class="s1">&#39;role&#39;</span><span class="o">:</span> <span class="nx">role</span>
            <span class="p">});</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Unregisters a component.</span>
<span class="cm">         *</span>
<span class="cm">         * @method unregisterComponent</span>
<span class="cm">         * @param {Module} component the module to unregister</span>
<span class="cm">         * @return {void}</span>
<span class="cm">         */</span>
        <span class="nx">unregisterComponent</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">component</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">components</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">components</span><span class="p">;</span>

            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">id</span> <span class="k">in</span> <span class="nx">components</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">components</span><span class="p">[</span><span class="nx">id</span><span class="p">].</span><span class="nx">component</span> <span class="o">===</span> <span class="nx">component</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">delete</span> <span class="nx">components</span><span class="p">[</span><span class="nx">id</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">},</span>

        <span class="cm">/**</span>
<span class="cm">         * Notifies all registered components about the state change (to be overriden in the specific connectors).</span>
<span class="cm">         *</span>
<span class="cm">         * @method notify</span>
<span class="cm">         * @param {Module} component the module that sends the state change</span>
<span class="cm">         * @param {String} state the state</span>
<span class="cm">         * @param {Object} data contains the state relevant data (if any)</span>
<span class="cm">         * @param {Function} callback the callback function (could be executed after an asynchronous action)</span>
<span class="cm">         * @return {boolean} indicates whether the default action should be excuted or not</span>
<span class="cm">         */</span>
        <span class="nx">notify</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">component</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* </span>
<span class="cm">             * gives the components the ability to prevent the default- and afteraction from the events</span>
<span class="cm">             * (by returning false in the on&lt;Event&gt;-Handler)</span>
<span class="cm">             */</span>
            <span class="kd">var</span> <span class="nx">proceed</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span>
                <span class="nx">components</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">components</span><span class="p">;</span>

            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">id</span> <span class="k">in</span> <span class="nx">components</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">components</span><span class="p">[</span><span class="nx">id</span><span class="p">].</span><span class="nx">component</span> <span class="o">!==</span> <span class="nx">component</span> <span class="o">&amp;&amp;</span> <span class="nx">components</span><span class="p">[</span><span class="nx">id</span><span class="p">].</span><span class="nx">component</span><span class="p">[</span><span class="nx">state</span><span class="p">])</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nx">components</span><span class="p">[</span><span class="nx">id</span><span class="p">].</span><span class="nx">component</span><span class="p">[</span><span class="nx">state</span><span class="p">](</span><span class="nx">data</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="o">===</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
                        <span class="nx">proceed</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="nx">proceed</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">})(</span><span class="nx">Tc</span><span class="p">.</span><span class="nx">$</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Contains utility functions for several tasks.</span>
<span class="cm"> */</span>
<span class="nx">Tc</span><span class="p">.</span><span class="nx">Utils</span> <span class="o">=</span> <span class="p">{};</span>

<span class="cm">/**</span>
<span class="cm"> * Contains utility functions for string concerning tasks.</span>
<span class="cm"> *</span>
<span class="cm"> * @author Remo Brunschwiler</span>
<span class="cm"> * @namespace Tc.Utils</span>
<span class="cm"> * @class String</span>
<span class="cm"> * @static</span>
<span class="cm"> */</span>
<span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">$</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">Tc</span><span class="p">.</span><span class="nx">Utils</span><span class="p">.</span><span class="nb">String</span> <span class="o">=</span> <span class="p">{</span>
        <span class="cm">/**</span>
<span class="cm">         * Capitalizes the first letter of the given string.</span>
<span class="cm">         *</span>
<span class="cm">         * @method capitalize</span>
<span class="cm">         * @param {String} str the original string</span>
<span class="cm">         * @return {String} the capitalized string</span>
<span class="cm">         */</span>
        <span class="nx">capitalize</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// capitalize the first letter</span>
            <span class="k">return</span> <span class="nx">str</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span><span class="nx">toUpperCase</span><span class="p">().</span><span class="nx">concat</span><span class="p">(</span><span class="nx">str</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">};</span>   
<span class="p">})(</span><span class="nx">Tc</span><span class="p">.</span><span class="nx">$</span><span class="p">);</span>
</pre></div>
